/**
 * Workflow Registry
 * Loads predefined n8n JSON workflows and persists user-created workflows.
 */

import gradeAssignmentsWorkflow from './workflows/grade-assignments.json';
import studentAnalyticsWorkflow from './workflows/student-analytics.json';
import generateRubricWorkflow from './workflows/generate-rubric.json';
import generateFeedbackWorkflow from './workflows/generate-feedback.json';
import { WorkflowGenerator, type TaskInput } from './WorkflowGenerator';

const CUSTOM_WORKFLOWS_STORAGE_KEY = 'autograder.customWorkflows.v1';

export interface WorkflowMetadata {
  id: string;
  taskId: number;
  name: string;
  description: string;
  icon: string;
  outputFormat: 'csv' | 'pdf' | 'json';
  workflow: any;
  prompt?: string;
  createdAt?: string;
  isPredefined?: boolean;
}

export class WorkflowRegistry {
  private static instance: WorkflowRegistry;
  private workflows: Map<number, WorkflowMetadata> = new Map();

  private constructor() {
    this.initializeWorkflows();
    this.loadCustomWorkflows();
  }

  static getInstance(): WorkflowRegistry {
    if (!WorkflowRegistry.instance) {
      WorkflowRegistry.instance = new WorkflowRegistry();
    }
    return WorkflowRegistry.instance;
  }

  /**
   * Initialize predefined workflows from static JSON files.
   */
  private initializeWorkflows(): void {
    this.workflows.set(1, {
      id: 'grade-assignments-001',
      taskId: 1,
      name: 'Grade Assignments',
      description: 'Analyze and grade student assignments based on rubric criteria',
      icon: 'ðŸ“',
      outputFormat: 'csv',
      workflow: gradeAssignmentsWorkflow,
      isPredefined: true
    });

    this.workflows.set(2, {
      id: 'generate-rubric-002',
      taskId: 2,
      name: 'Generate Rubric',
      description: 'Create comprehensive grading rubrics',
      icon: 'ðŸ“‹',
      outputFormat: 'pdf',
      workflow: generateRubricWorkflow,
      isPredefined: true
    });

    this.workflows.set(3, {
      id: 'student-analytics-003',
      taskId: 3,
      name: 'Student Analytics',
      description: 'Analyze student performance and identify at-risk students',
      icon: 'ðŸ“Š',
      outputFormat: 'pdf',
      workflow: studentAnalyticsWorkflow,
      isPredefined: true
    });

    this.workflows.set(4, {
      id: 'generate-feedback-004',
      taskId: 4,
      name: 'Generate Feedback',
      description: 'Create personalized student feedback',
      icon: 'ðŸ’¬',
      outputFormat: 'csv',
      workflow: generateFeedbackWorkflow,
      isPredefined: true
    });

    console.log('Workflow Registry initialized with 4 predefined workflows');
  }

  /**
   * Load custom workflows previously generated by users.
   * In SSR environments this is intentionally skipped.
   */
  private loadCustomWorkflows(): void {
    if (typeof window === 'undefined') {
      return;
    }

    try {
      const raw = localStorage.getItem(CUSTOM_WORKFLOWS_STORAGE_KEY);
      if (!raw) {
        return;
      }

      const stored = JSON.parse(raw) as WorkflowMetadata[];
      if (!Array.isArray(stored)) {
        return;
      }

      for (const item of stored) {
        if (!item || typeof item.taskId !== 'number' || !item.workflow) {
          continue;
        }

        // Never override predefined workflows.
        if (this.workflows.has(item.taskId) && this.workflows.get(item.taskId)?.isPredefined) {
          continue;
        }

        this.workflows.set(item.taskId, {
          ...item,
          isPredefined: false
        });
      }
    } catch (error) {
      console.error('Failed to load custom workflows from storage:', error);
    }
  }

  /**
   * Persist custom workflows only.
   */
  private persistCustomWorkflows(): void {
    if (typeof window === 'undefined') {
      return;
    }

    try {
      const customWorkflows = Array.from(this.workflows.values()).filter(
        (wf) => !wf.isPredefined
      );
      localStorage.setItem(CUSTOM_WORKFLOWS_STORAGE_KEY, JSON.stringify(customWorkflows));
    } catch (error) {
      console.error('Failed to persist custom workflows:', error);
    }
  }

  getWorkflow(taskId: number): WorkflowMetadata | null {
    return this.workflows.get(taskId) || null;
  }

  getAllWorkflows(): WorkflowMetadata[] {
    return Array.from(this.workflows.values());
  }

  hasWorkflow(taskId: number): boolean {
    return this.workflows.has(taskId);
  }

  /**
   * Register a workflow in memory and optionally persist it.
   */
  registerWorkflow(metadata: WorkflowMetadata, options?: { persist?: boolean }): void {
    this.workflows.set(metadata.taskId, metadata);

    const shouldPersist = options?.persist ?? !metadata.isPredefined;
    if (shouldPersist) {
      this.persistCustomWorkflows();
    }

    console.log(`Workflow registered: ${metadata.name}`);
  }

  /**
   * Generate a real JSON workflow once for a new task, then persist it.
   */
  async generateAndRegisterWorkflow(task: TaskInput): Promise<WorkflowMetadata> {
    const existing = this.getWorkflow(task.id);
    if (existing) {
      return existing;
    }

    console.log(`Generating workflow for new task: ${task.title}`);

    const generator = WorkflowGenerator.getInstance();
    const workflow = await generator.generateWorkflow(task);
    const outputFormat = this.determineOutputFormat(workflow);

    const metadata: WorkflowMetadata = {
      id: workflow.id,
      taskId: task.id,
      name: task.title,
      description: task.description,
      icon: task.icon,
      outputFormat,
      workflow,
      prompt: task.prompt,
      createdAt: new Date().toISOString(),
      isPredefined: false
    };

    this.registerWorkflow(metadata, { persist: true });
    console.log(`Workflow generated and registered: ${metadata.name}`);

    return metadata;
  }

  private determineOutputFormat(workflow: any): 'csv' | 'pdf' | 'json' {
    const exportNode = workflow.nodes.find(
      (n: any) => n.type === 'n8n-nodes-base.convertToFile'
    );

    if (exportNode) {
      const format =
        exportNode.parameters?.fileFormat ||
        exportNode.parameters?.options?.fileFormat ||
        'csv';
      return format as 'csv' | 'pdf' | 'json';
    }

    return 'csv';
  }

  getWorkflowCount(): number {
    return this.workflows.size;
  }
}
